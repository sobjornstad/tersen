# Tersen

**Tersen** is an abbreviation engine
    that compresses text in a human-readable fashion.
Abbreviations are entirely user-specifiable
    through a dictionary of textual mappings (e.g., `and` becomes `&`).
More concise dictionary files and custom abbreviation behavior
    can be obtained by writing Lua functions called
    *annotations* (which pre-process lines in the abbreviation dictionary)
    and *hooks* (which alter tersen's behavior as it abbreviates a text).

Use cases for tersen include:

* Packing more information onto a cheat sheet or reference guide.
* Sending content over SMS or another limited-bandwidth communication channel.
* Obfuscating content so others cannot easily read it but you can.
* Practicing your reading skills in your favorite alphabetic shorthand system.

Tersen is written in Lua.
It is fast, flexible, and small.


## Concepts

### Mappings

To tell tersen how you want to abbreviate things,
    you create a tersen dictionary which contains one or more *mappings*.
A mapping consists of one or more source tokens (e.g., `Internet`)
    and a destination string (e.g., `I.N.`).
When tersen encounters the source token(s) in its input,
    it will replace them with the destination string in its output.


### Tokens

Tokens are the unit of processing in tersen.
*Outer tokens* are strings of characters separated by whitespace.
Each outer token has an associated *inner token*,
    which is the part of the outer token beginning at the first inner-token character
    and ending at the first non-inner-token character.
Inner-token characters are the alphanumeric characters in your system locale,
     `-`, `'`, and `’`.
The portions of an outer token that are not part of the inner token
    are the *initial* and *final* portions,
    or, together, the *token perimeter*.

Only the inner token is used for matching purposes,
    but the token perimeter is preserved in the output
    (e.g., with the mapping presented above,
     if `Internet,` was found in the source,
     `I.N.,` would appear in the destination).

Note that the definition above allows the final portion of the token
    to contain alphanumeric characters.
This might happen, for instance, if your source contains
    a phrase like `Wolfram|Alpha` -- `Wolfram` would be matched,
    while `|Alpha` would be ignored and passed through verbatim.


### Sources

A source may consist of one token or several tokens.
When tersen encounters an input token
    that could begin multiple mappings,
    it looks ahead and picks the longest possible match.
For instance,
    if your dictionary contains both `Internet` and `Internet Protocol`,
    the phrase `the Internet is` becomes `the I.N. is`,
    while `Internet Protocol` becomes `IP` (not `I.N. Protocol`).
The “longest possible match” is the one with the most tokens;
    it is not necessarily the way of dividing tokens
    that produces the shortest output.
(tersen is *greedy*;
    it will never backtrack over a replacement it has already made,
    even if another division of tokens could produce a shorter output.
 While that gives up a small amount of possible compression,
    it keeps tersen fast and simple
    and makes replacement behavior more predictable.)

A source can contain only inner tokens;
    that is, it cannot contain punctuation other than hyphens or apostrophes.
So you cannot have a source of, say, `#&$%`, or `St. Paul`.
If such a source is found,
    a warning will be printed and that mapping will be ignored.
However, this doesn't necessarily mean that you can't match phrases
    that have punctuation in the middle;
    if a multi-word phrase matches input
    when ignoring the punctuation in the input,
    the replacement will still be made
    and any medial punctuation will disappear.
For instance, if you have a mapping from `St Olaf` to `STO`,
    and the text `St. Olaf` is found in the input,
    it will be replaced with `STO`.
One could imagine a case where this would do the wrong thing,
    such as “222 Somewhere St., Olaf City, CA”,
    but in general this is unlikely
    (and it will always be possible to fool tersen in some edge cases!).

Only one mapping may be present in the dictionary for each `source`.
If the same source is mapped more than once,
    the mapping that comes physically first in the source file wins.
For mappings beyond the first,
    tersen will print a warning,
    unless the duplicate is programmically generated by an annotation
    or the `-` flag is used on the entry
    (see later for more on annotations and flags).
This behavior can be customized via the `mapping_conflicts` hook,
    so you can have later mappings overwrite earlier ones, for example.


### Destinations

A destination may be any string containing any characters,
    including whitespace and punctuation,
    with the sole exception of the newline and the at-sign (`@`),
    which both indicate the end of the destination string
    (the at-sign additionally applies annotations).
Leading and trailing whitespace in the destination string are ignored.

If a destination is longer (consists of more characters)
    than its corresponding source,
    tersen will print a warning but still use the mapping.
This behavior can be customized via the `mapping_verbosens_text` hook.


## Flags

The following characters of punctuation, called *flags*,
    when placed at the start of a line in the tersen dictionary,
    have special effects.
Any number of flags can be used together,
    and if the same flag is used twice,
    tersen will behave as if it were used only once.

* `!` – The *cut* flag causes tersen to
  stop parsing the dictionary immediately after this entry.
  This may be useful if you’re trying to debug a small portion of the dictionary.
  To reduce the risk of accidentally leaving a cut in the dictionary file,
      a warning will be printed anytime a cut is present,
      indicating which line the cut is on.

* `?` – The *trace* flag causes tersen to
  print its internal lookup-table structure
  for all entries generated by this dictionary line.
  This can be useful when debugging annotations.
  For multi-word tokens, the structure will be printed back from the first token
  (so if “Internet Protocol” has a ? by it,
   the entry for “Internet” will appear,
   containing “Internet Protocol” as a continuation member).
  Note that the trace is printed for all flagged items
  after the entire lookup table is built;
  if the entry being traced is not actually inserted successfully
  (for instance, because it had the same source as an earlier entry),
  nothing will show up in the trace.

  A warning is printed anytime a trace is present.

* `-` – The *suppress redefinition* flag silences any warnings
  that would otherwise be displayed if any mappings created by this line
  conflict with existing mappings.
  This only affects the display of the warning;
  the original mappings will win, as they would without the flag.
  This flag is useful when using an annotation that happens to generate
  an item with the same source as a previous mapping;
  for instance, the present tense of the verb `lead`
  and the singular form of the noun `lead` are identical,
  but you might want to include their base forms
  and attach noun and verb annotations to them in the dictionary.


## The tersen dictionary

The abbreviation table is defined in a *tersen dictionary*,
    a text file with the following format.

Lines beginning with the comment character `#` and blank lines are ignored.
All other lines create one or more mappings.
The ordering of entries in the dictionary does not matter,
    unless you map the same source to multiple destinations,
    in which case the first one wins.

The simplest kind of dictionary line looks like this:

    source => destination

This creates a mapping that will replace `source` with `destination` in output.

You may want to map several sources to the same destination.
You can do this by separating them with commas:

    source1, source2 => destination

You can also apply an *annotation* to any dictionary line,
    which is done by putting an at-sign,
    the name of the annotation,
    and optionally some parameters at the end of the line.
For instance, you might write:

    you're => v_e @apos

Or:

    easy => fas @adj[easier easiest]

The annotation is backed by a Lua function in the file `annot.lua`
    that receives the source, destination, and arguments,
    alters or expands what would have been the original mapping in some way,
    and returns a series of mappings that land in tersen's lookup table.
See the *Annotations* section for details.

If you annotate a line that has comma-separated sources,
    the annotation function will be applied to each of the sources in turn.


## Miscellaneous notes

### Case

Tersen is case-insensitive when matching,
    to the extent that your system locale
    can lowercase the characters you’re working with.
When replacing a match,
    tersen uses some simple rules to determine the case of the output:

* If the destination, as defined in the tersen dictionary, is all-caps,
  tersen assumes this is an acronym,
  and the output will always be all-caps.
* If the matched text itself was all-caps, its tersened output will be as well.
* If the matched text was title case,
  its tersened output will be in title case.
* Otherwise, the output will be whatever case the replacement is.

Though these rules are not always perfect,
    for the most part, tersen will just “do the right thing” with case.
If you find it is doing the wrong thing,
    you can customize the rules via the `normalize_case` hook.


### Dot-coalescing

If a replacement ends with `.`
    but a `.` already comes after the matched tokens in the source,
    tersen will remove exactly one dot from the sequence;
    this prevents sentences ending with `..`
    because the last word was substituted with a period-ending abbreviation.
(If the matched tokens had *more* than one dot after them
    – for instance, if the sentence ended in an ellipsis –
    only one of them will be removed.)


## Extending tersen

Tersen is intended to have sane default behavior for most use cases,
    but there are a wide variety
    of languages and abbreviation systems in the world,
    so its default behavior may not be suitable for all of them.
Additionally, some abbreviation systems may require
    adding an excessive number of similar entries to the tersen dictionary,
    which is boring and error-prone.
To make tersen more flexible,
    extensibility points in the form of *annotations* and *hooks* are provided.

If you've ever written any code at all,
    you should be able to figure out annotations and hooks in a few minutes;
    they are quite straightforward.


### Annotations

Annotations are Lua functions
    that transform the source and destination of a mapping in an arbitrary way.
An annotation can output one mapping or many mappings;
    for instance, you might wish to add both the singular form
    and a plural form of a word using an annotation.
Several annotations are provided with tersen,
    and you can easily write your own.

#### Dictionary syntax

Annotations can be written three different ways in the tersen dictionary.
The first is *argumentless*:

    tree => bo @n

The second uses a single pair of square brackets to delimit the arguments,
    and individual arguments are separated by spaces:

    easy => fas @adj[easier easiest]

Each argument can contain any character
    except whitespace and closing square brackets.

The third and last uses curly braces,
    with each argument in a separate pair of braces:

    log in => lgn @v{logs in}{logged in}{logged in}{logging in}

Each argument can contain any character except newlines and closing curly braces.

With an argumentless annotation,
    your annotation function will get `nil` as its third argument.
With either the second or third form,
    your annotation function will get a list of the parameters
    as its third argument.


#### Backing functions

Annotations are processed by Lua functions
    in the `M` table in the `annot.lua` file.
The name of the function
    is the name used to access the annotation in the tersen dictionary,
    and may contain lowercase letters, numbers, and underscores
    (annotations in the tersen dictionary are flattened to lowercase,
     so if you use uppercase in your name it will be impossible to call it).

Each annotation function takes three arguments:
    the source listed in the tersen dictionary,
    the destination listed in the tersen dictionary,
    and a list of arguments to the annotation (or nil if there were no arguments).
It returns a table of mappings,
    the keys being sources and the values being destinations.

If there are multiple comma-separated sources,
    the annotation function is called separately for each source.

Here’s a simple example, the built-in function for `@apos`,
    which ensures that any apostrophes in the source value
    get dictionary entries for both curly apostrophes and straight apostrophes.

    function M.apos (source, dest, args)
        local straight = string.gsub(source, "'", "’")
        local curly = string.gsub(source, "’", "'")
        return {[straight] = dest, [curly] = dest}
    end

It’s possible to use an annotation to programmatically generate some entries
    without using the dictionary entry at all – 
    there’s no requirement that all the arguments to the function be used.
For instance, the default `@numbers` annotation
    adds entries for the words “one” through “ninety-nine”
    and their corresponding digit representations.
To include the output of such an annotation in your dictionary,
    simply put a dummy source and replacement on a line
    and attach the annotation, like so:

    Numbers as Words => Digits @numbers

You can trace this line to see the effect if you like,
    by placing a `?` in front of it (see *Flags*, below).

If you prefer, you can get the same generation effect
    using the `post_build_lut` hook.


### Hooks

Tersen has various hooks scattered throughout its codebase.
By uncommenting a hook and giving it an implementation in `hooks.lua`,
    you can change the behavior of a small piece of tersen's process.
For instance, you might want to change
    what happens if a source is defined twice in the dictionary,
    or how the case of replacements is set.
The names of hooks that can be used to customize behavior
    have been mentioned throughout this manual.
All available hooks have commented-out stub implementations and extensive comments
    on parameters, return values, and general usage
    already in `hooks.lua`,
    so you should review that file for further information.


## Performance

tersen is designed to be fast enough
    that performance should not normally be a concern.
However, depending on what features you take advantage of,
    what kind of speed you require,
    and how much input you intend to pass to tersen,
    you may want to consider a few things.

Building the lookup table is almost instantaneous in most cases,
    even with annotations.
A 700-line tersen dictionary with liberal use of moderately complex annotations
    and multiple sources takes under 10ms to build on my computer
    (NB: my development machine is unusually fast for a desktop).
Thus, the main factor is usually how large your input is;
    on the same machine and a large corpus,
    tersen works at about 0.45 seconds per megabyte of input.
(You can manage faster if you don't use any hooks.)

A significant secondary factor is the use of hooks, particularly no_match.
Since `no_match` runs against every word in the source text which doesn't match
    -- which even in a good abbreviation table will usually be a large fraction of them --
    this is a very "hot" function
     and almost anything you can do to speed it up will have a noticeable impact.
`normalize_case` has similar concerns.
